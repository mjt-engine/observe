(function(c,f){typeof exports=="object"&&typeof module<"u"?f(exports):typeof define=="function"&&define.amd?define(["exports"],f):(c=typeof globalThis<"u"?globalThis:c||self,f(c.Module={}))})(this,function(c){"use strict";const f=e=>{const t=e.split("."),n=t.shift(),r=t.join(".");return{root:n,segments:t,subpath:r}},h=e=>e==null||Number.isNaN(e),v={isDefined:e=>!h(e),isUndefined:h},{isDefined:m,isUndefined:L}=v,O=(e,t,n)=>{if(L(e))return;const r=t.get(e);if(m(r))return r;if(m(n)){const s=n();return t.set(e,s),s}},$={create:()=>{const e=new Map;let t=performance.now();const n={get:(r,s)=>O(r,e,s),set:(r,s)=>(e.set(r,s),n),delete:r=>e.delete(r),entries:()=>Array.from(e.entries()),clear:()=>e.clear(),size:()=>e.size,findKeys:r=>Array.from(e.entries()).filter(([a,u])=>u===r).map(([a,u])=>a),lastUpdate:()=>t};return n}},y=e=>t=>{if(typeof e=="string")return new RegExp(e).test(t.traceId);const{traceId:n,message:r,extra:s=()=>!0,timestamp:a=()=>!0}=e;return!(n&&!new RegExp(n).test(t.traceId)||r&&!new RegExp(r).test(t.message)||t.timestamp&&!a(t.timestamp)||t.extra&&!s(t.extra))},A=e=>t=>{for(const n of e)if(y(n)(t))return n;return!1},C=e=>t=>typeof e=="string"?t:e.transform?e.transform(t):t,l=e=>{const t=[],n={length:0,push:r=>{t.length>=e&&t.shift(),t.push(r),n.length=t.length},get:()=>t,clear:()=>{t.length=0,n.length=0},last:()=>t[t.length-1]};return n},p=()=>{let e=performance.now(),t;const n={end:()=>(m(t)||(t=performance.now()),n),getDuration:()=>(t??performance.now())-e};return n},w=(e=100)=>{let t=0;const n=new Map,r=new Map,s=new Map,a=l(e),u={clear:()=>(t=0,n.clear(),r.clear(),s.clear(),a.clear(),u),lastTime:()=>a.last(),time:()=>{const o=u.lastTime();m(o)&&o.end();const i=p();return a.push(i),i},getTimes:()=>a.get(),timer:o=>{const i=s.get(o)??l(e);s.set(o,i);const g=p();return i.push(g),g},increment:(o,i=1)=>{const g=n.get(o)??0;n.set(o,g+i)},gauge:(o,i=0)=>{r.set(o,i)},getCounters:()=>new Map(n),getCounter:o=>n.get(o)??0,getGauge:o=>r.get(o)??0,getGauges:()=>new Map(r),count:(o=1)=>{t+=o},getCount:()=>t,getTimers:o=>(s.get(o)??l(e)).get()};return u},M=({logMatchers:e=[],logger:t=console.log,clock:n=performance,maxSampleSize:r=100}={})=>{const s=$.create(),a={updateLogMatchers:u=>{const o=u(e);return e=o,o},getTraceIds:()=>s.entries().map(([u])=>u),start:(u,...o)=>{a.getStats(u).count(),a.getStats(u).time(),a.log({traceId:u,message:"start",extra:o})},getStats:u=>s.get(u,()=>w(r)),log:({traceId:u,message:o,timestamp:i=n.now(),extra:g=[]})=>{const S={traceId:u,message:o,timestamp:i,extra:g},b=A(e)(S);if(!b)return;const d=C(b)(S);t(`${d.timestamp} ${d.traceId}: ${d.message}`,...d.extra??[])},end:(u,...o)=>{a.getStats(u).lastTime()?.end(),a.log({traceId:u,message:"end",extra:o})}};return a},T=(e="",t=M())=>{t.start(e);const n={span:r=>T(`${e}.${r}`,t),increment:(r,s=1)=>(t.getStats(e).increment(r,s),n),sample:(r,s,a)=>{if(Math.random()<r){const u=a();n.gauge(s,u)}return n},when:(r,s,a)=>{if(r()){const u=a();n.gauge(s,u)}return n},gauge:(r,s)=>(t.getStats(e).gauge(r,s),n),timer:r=>t.getStats(e).timer(r),end:()=>(t.end(e),n),log:(r,...s)=>(t.log({traceId:e,message:r,extra:s}),n)};return n};c.Observe=T,c.ObserveAgent=M,c.Stats=w,c.Timer=p,c.parseTraceId=f,Object.defineProperty(c,Symbol.toStringTag,{value:"Module"})});
