(function(c,g){typeof exports=="object"&&typeof module<"u"?g(exports):typeof define=="function"&&define.amd?define(["exports"],g):(c=typeof globalThis<"u"?globalThis:c||self,g(c.Module={}))})(this,function(c){"use strict";const g=e=>{const t=e.split("."),n=t.shift(),r=t.join(".");return{root:n,segments:t,subpath:r}},L=e=>typeof e=="function",h=e=>e==null||Number.isNaN(e),w=e=>!h(e),O=e=>L(e)?e():e,$={isDefined:w,isUndefined:h,safe:(e,t={})=>{const{quiet:n=!1,default:r=void 0,onError:s}=t;try{return e()}catch(a){return n||(console.error(a),w(s)&&console.log(O(s))),r}}},{isDefined:l,isUndefined:v,safe:A}=$,C=(e,t,n)=>{if(v(e))return;const r=t.get(e);if(l(r))return r;if(l(n)){const s=n();return t.set(e,s),s}},U={create:()=>{const e=new Map;let t=performance.now();const n={get:(r,s)=>C(r,e,s),set:(r,s)=>(e.set(r,s),n),delete:r=>e.delete(r),entries:()=>Array.from(e.entries()),clear:()=>e.clear(),size:()=>e.size,findKeys:r=>Array.from(e.entries()).filter(([a,u])=>u===r).map(([a,u])=>a),lastUpdate:()=>t};return n}},x=e=>t=>{if(typeof e=="string")return A(()=>new RegExp(e).test(t.traceId),{default:!1});const{traceId:n,message:r,extra:s=()=>!0,timestamp:a=()=>!0}=e;return!(n&&!new RegExp(n).test(t.traceId)||r&&!new RegExp(r).test(t.message)||t.timestamp&&!a(t.timestamp)||t.extra&&!s(t.extra))},D=e=>t=>{for(const n of e)if(x(n)(t))return n;return!1},j=e=>t=>typeof e=="string"?t:e.transform?e.transform(t):t,m=e=>{const t=[],n={length:0,push:r=>{t.length>=e&&t.shift(),t.push(r),n.length=t.length},get:()=>t,clear:()=>{t.length=0,n.length=0},last:()=>t[t.length-1]};return n},p=()=>{let e=performance.now(),t;const n={end:()=>(l(t)||(t=performance.now()),n),getDuration:()=>(t??performance.now())-e};return n},M=(e=100)=>{let t=0;const n=new Map,r=new Map,s=new Map,a=m(e),u={clear:()=>(t=0,n.clear(),r.clear(),s.clear(),a.clear(),u),lastTime:()=>a.last(),time:()=>{const o=u.lastTime();l(o)&&o.end();const i=p();return a.push(i),i},getTimes:()=>a.get(),timer:o=>{const i=s.get(o)??m(e);s.set(o,i);const f=p();return i.push(f),f},increment:(o,i=1)=>{const f=n.get(o)??0;n.set(o,f+i)},gauge:(o,i=0)=>{r.set(o,i)},getCounters:()=>new Map(n),getCounter:o=>n.get(o)??0,getGauge:o=>r.get(o)??0,getGauges:()=>new Map(r),count:(o=1)=>{t+=o},getCount:()=>t,getTimers:o=>(s.get(o)??m(e)).get()};return u},T=({logMatchers:e=[],logger:t=console.log,clock:n=performance,maxSampleSize:r=100}={})=>{const s=U.create(),a={updateLogMatchers:u=>{const o=u(e);return e=o,o},getTraceIds:()=>s.entries().map(([u])=>u),start:(u,...o)=>{a.getStats(u).count(),a.getStats(u).time(),a.log({traceId:u,message:"start",extra:o})},getStats:u=>s.get(u,()=>M(r)),log:({traceId:u,message:o,timestamp:i=n.now(),extra:f=[]})=>{const b={traceId:u,message:o,timestamp:i,extra:f},y=D(e)(b);if(!y)return;const d=j(y)(b);t(`${d.timestamp} ${d.traceId}: ${d.message}`,...d.extra??[])},end:(u,...o)=>{a.getStats(u).lastTime()?.end(),a.log({traceId:u,message:"end",extra:o})}};return a},S=(e="",t=T())=>{t.start(e);const n={span:r=>S(`${e}.${r}`,t),increment:(r,s=1)=>(t.getStats(e).increment(r,s),n),sample:(r,s,a)=>{if(Math.random()<r){const u=a();n.gauge(s,u)}return n},when:(r,s,a)=>{if(r()){const u=a();n.gauge(s,u)}return n},gauge:(r,s)=>(t.getStats(e).gauge(r,s),n),timer:r=>t.getStats(e).timer(r),end:()=>(t.end(e),n),log:(r,...s)=>(t.log({traceId:e,message:r,extra:s}),n)};return n};c.Observe=S,c.ObserveAgent=T,c.Stats=M,c.Timer=p,c.parseTraceId=g,Object.defineProperty(c,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=index.umd.cjs.map
