{"version":3,"file":"index.umd.cjs","sources":["../src/type/TraceId.ts","../node_modules/.pnpm/@mjt-engine+object@https+++codeload.github.com+mjt-engine+object+tar.gz+cf5530e63f97f9ecf37d8b32674818b5c0c614fd/node_modules/@mjt-engine/object/dist/object/type/Producer.js","../node_modules/.pnpm/@mjt-engine+object@https+++codeload.github.com+mjt-engine+object+tar.gz+cf5530e63f97f9ecf37d8b32674818b5c0c614fd/node_modules/@mjt-engine/object/dist/object/isUndefined.js","../node_modules/.pnpm/@mjt-engine+object@https+++codeload.github.com+mjt-engine+object+tar.gz+cf5530e63f97f9ecf37d8b32674818b5c0c614fd/node_modules/@mjt-engine/object/dist/object/isDefined.js","../node_modules/.pnpm/@mjt-engine+object@https+++codeload.github.com+mjt-engine+object+tar.gz+cf5530e63f97f9ecf37d8b32674818b5c0c614fd/node_modules/@mjt-engine/object/dist/object/valueOf.js","../node_modules/.pnpm/@mjt-engine+object@https+++codeload.github.com+mjt-engine+object+tar.gz+cf5530e63f97f9ecf37d8b32674818b5c0c614fd/node_modules/@mjt-engine/object/dist/object/Objects.js","../node_modules/.pnpm/@mjt-engine+object@https+++codeload.github.com+mjt-engine+object+tar.gz+cf5530e63f97f9ecf37d8b32674818b5c0c614fd/node_modules/@mjt-engine/object/dist/object/safe.js","../node_modules/.pnpm/@mjt-engine+object@https+++codeload.github.com+mjt-engine+object+tar.gz+cf5530e63f97f9ecf37d8b32674818b5c0c614fd/node_modules/@mjt-engine/object/dist/index.js","../node_modules/.pnpm/@mjt-engine+cache@https+++codeload.github.com+mjt-engine+cache+tar.gz+1f7dba33f49bce1a232d2c147441579f026512a5/node_modules/@mjt-engine/cache/dist/cache/getCachedObject.js","../node_modules/.pnpm/@mjt-engine+cache@https+++codeload.github.com+mjt-engine+cache+tar.gz+1f7dba33f49bce1a232d2c147441579f026512a5/node_modules/@mjt-engine/cache/dist/cache/Caches.js","../src/agent/logMatcherMatchesLogEntry.ts","../src/agent/atLeastOneLogMatcherMatchesLogEntry.ts","../src/agent/transformLogEntry.ts","../src/agent/MaxLengthArray.ts","../src/agent/Timer.ts","../src/agent/Stats.ts","../src/agent/ObserveAgent.ts","../src/observe/Observe.ts"],"sourcesContent":["\nexport type TraceId<T extends string = string> = `${T}.${string}` | T;\n\nexport type ParsedTraceId<T extends string = string> = {\n  root: T;\n  segments: string[];\n  subpath: string;\n};\n\nexport const parseTraceId = <T extends string = string>(\n  subject: TraceId<T>\n): ParsedTraceId<T> => {\n  const segments = subject.split(\".\");\n  const root = segments.shift() as T;\n  const subpath = segments.join(\".\");\n\n  return {\n    root,\n    segments,\n    subpath,\n  };\n};\n","export const isProducer = (valueProducer) => {\n    return typeof valueProducer === \"function\";\n};\n//# sourceMappingURL=Producer.js.map","export const isUndefined = (obj) => {\n    return obj === undefined || obj === null || Number.isNaN(obj);\n};\n//# sourceMappingURL=isUndefined.js.map","import { isUndefined } from \"./isUndefined\";\nexport const isDefined = (obj) => {\n    return !isUndefined(obj);\n};\n//# sourceMappingURL=isDefined.js.map","import { isProducer } from \"./type/Producer\";\nexport const valueOf = (valueProducer) => {\n    if (isProducer(valueProducer)) {\n        return valueProducer();\n    }\n    return valueProducer;\n};\n//# sourceMappingURL=valueOf.js.map","import { chain } from \"./chain\";\nimport { entries } from \"./entries\";\nimport { filter } from \"./filter\";\nimport { first } from \"./first\";\nimport { fix } from \"./fix/fix\";\nimport { forEach } from \"./forEach\";\nimport { freeze } from \"./freeze\";\nimport { fromEntries } from \"./fromEntries\";\nimport { fromEntriesToMultimap } from \"./fromEntriesToMultimap\";\nimport { get } from \"./get\";\nimport { hasKey } from \"./hasKey\";\nimport { headOf } from \"./headOf\";\nimport { iff } from \"./iff\";\nimport { iffBrowser } from \"./iffBrowser\";\nimport { iffTyped } from \"./iffTyped\";\nimport { includesUndefined } from \"./includesUndefined\";\nimport { isBrowser } from \"./isBrowser\";\nimport { isDefined } from \"./isDefined\";\nimport { isEmpty } from \"./isEmpty\";\nimport { isNotEmpty } from \"./isNotEmpty\";\nimport { isUndefined } from \"./isUndefined\";\nimport { keys } from \"./keys\";\nimport { last } from \"./last\";\nimport { mapValue } from \"./map\";\nimport { mapOf } from \"./mapOf\";\nimport { omit, omitUnsafe } from \"./omit\";\nimport { orElse } from \"./orElse\";\nimport { orError } from \"./orError\";\nimport { removeUndefinedValues } from \"./removeUndefinedValues\";\nimport { restOf } from \"./restOf\";\nimport { safe } from \"./safe\";\nimport { safeAsync } from \"./safeAsync\";\nimport { set, setUnsafe } from \"./set\";\nimport { tailOf } from \"./tailOf\";\nimport { times } from \"./times\";\nimport { timesGen } from \"./timesGen\";\nimport { toBoolean } from \"./toBoolean\";\nimport { toMany } from \"./toMany\";\nimport { toMultiMap } from \"./toMultiMap\";\nimport { toNumber } from \"./toNumber\";\nimport { toPromise } from \"./toPromise\";\nimport { tryValue } from \"./tryValue\";\nimport { tuple0, tuple1, tuple2, tuple3, tuple4, tuple5 } from \"./tuples\";\nimport { isArrayLike } from \"./type/isArrayLike\";\nimport { isErrorLike } from \"./type/isErrorLike\";\nimport { isErrorType } from \"./type/isErrorType\";\nimport { isFunction } from \"./type/isFunction\";\nimport { isIterable } from \"./type/isIterable\";\nimport { isIterator } from \"./type/isIterator\";\nimport { update, updateUnsafe } from \"./update\";\nimport { valueOf } from \"./valueOf\";\nimport { values } from \"./values\";\nimport { waitTimeout } from \"./waitTimeout\";\nimport { createSettler } from \"./createSettler\";\nimport { parseIncompleteJson } from \"./parseIncompleteJson\";\nimport { lengthOf } from \"./lengthOf\";\nexport const Objects = {\n    lengthOf,\n    isErrorLike,\n    orError,\n    tryValue,\n    isErrorType,\n    isEmpty,\n    isNotEmpty,\n    isIterator,\n    isArrayLike,\n    times,\n    first,\n    last,\n    fix,\n    iff,\n    iffTyped,\n    includesUndefined,\n    isDefined,\n    isUndefined,\n    omit,\n    omitUnsafe,\n    orElse,\n    removeUndefinedValues,\n    toMany,\n    set,\n    setUnsafe,\n    get,\n    update,\n    updateUnsafe,\n    entries,\n    keys,\n    values,\n    forEach,\n    filter,\n    chain,\n    fromEntries,\n    fromEntriesToMultimap,\n    freeze,\n    hasKey,\n    tuple0,\n    tuple1,\n    tuple2,\n    tuple3,\n    tuple4,\n    tuple5,\n    safe,\n    safeAsync,\n    valueOf,\n    mapValue,\n    headOf,\n    tailOf,\n    restOf,\n    toMultiMap,\n    timesGen,\n    isIterable,\n    isBrowser,\n    iffBrowser,\n    mapOf,\n    toPromise,\n    all: Promise.all,\n    isFunction,\n    toNumber,\n    toBoolean,\n    waitTimeout,\n    createSettler,\n    parseIncompleteJson,\n};\nexport * from \"./tuples\";\n//# sourceMappingURL=Objects.js.map","import { isDefined } from \"./isDefined\";\nimport { valueOf } from \"./valueOf\";\nexport const safe = (producer, options = {}) => {\n    const { quiet = false, default: def = undefined, onError } = options;\n    try {\n        return producer();\n    }\n    catch (error) {\n        if (!quiet) {\n            console.error(error);\n            if (isDefined(onError)) {\n                console.log(valueOf(onError));\n            }\n        }\n        return def;\n    }\n};\n//# sourceMappingURL=safe.js.map","export * from \"./object/brand/type/Brand\";\nexport * from \"./object/type/ErrorLike\";\nexport * from \"./object/type/Nullable\";\nexport * from \"./object/type/Producer\";\nexport * from \"./object/type/TypeGuard\";\nexport * from \"./object/type/Indexable\";\nexport * from \"./object/type/Indexable\";\nexport * from \"./object/type/TypedArray\";\nexport * from \"./object/Arrays\";\nexport * from \"./object/Objects\";\nexport * from \"./object/fix/Fixes\";\nexport * from \"./object/fix/extend\";\nexport * from \"./object/fix/fix\";\nexport * from \"./object/fix/fixArray\";\nexport * from \"./object/fix/fixObject\";\nexport * from \"./object/fix/type/Fixed\";\nimport { Objects } from \"./object/Objects\";\nexport * from \"./key/Keys\";\nexport * from \"./object/typebox/TypeBoxes\";\nexport const { lengthOf, isErrorLike, chain, entries, filter, first, last, forEach, iff, orElse, removeUndefinedValues, iffTyped, isDefined, isUndefined, omit, omitUnsafe, toMany, fromEntries, safe, safeAsync, mapValue, headOf, tailOf, restOf, times, isIterator, toMultiMap, timesGen, isIterable, isArrayLike, iffBrowser, isBrowser, toPromise, all, isFunction, isEmpty, isNotEmpty, tryValue, orError, isErrorType, createSettler, } = Objects;\n//# sourceMappingURL=index.js.map","import { isDefined, isUndefined } from \"@mjt-engine/object\";\nexport const getCachedObject = (key, map, producer) => {\n    if (isUndefined(key)) {\n        return undefined;\n    }\n    const value = map.get(key);\n    if (isDefined(value)) {\n        return value;\n    }\n    if (isDefined(producer)) {\n        const product = producer();\n        map.set(key, product);\n        return product;\n    }\n    return undefined;\n};\n//# sourceMappingURL=getCachedObject.js.map","import { getCachedObject } from \"./getCachedObject\";\nconst create = () => {\n    const state = new Map();\n    let lastUpdated = performance.now();\n    const cache = {\n        get: (key, producer) => getCachedObject(key, state, producer),\n        set: (key, value) => {\n            state.set(key, value);\n            return cache;\n        },\n        delete: (key) => {\n            return state.delete(key);\n        },\n        entries: () => Array.from(state.entries()),\n        clear: () => state.clear(),\n        size: () => state.size,\n        findKeys: (value) => {\n            const entries = Array.from(state.entries());\n            return entries.filter(([k, v]) => v === value).map(([k, v]) => k);\n        },\n        lastUpdate: () => lastUpdated,\n    };\n    return cache;\n};\nexport const Caches = {\n    create,\n};\n//# sourceMappingURL=Caches.js.map","import { isDefined, safe } from \"@mjt-engine/object\";\nimport { LogEntry } from \"../type/LogEntry\";\nimport { LogMatcher } from \"../type/LogMatcher\";\n\nexport const logMatcherMatchesLogEntry =\n  (logMatcher: RegExp | string | LogMatcher) => (logEntry: LogEntry) => {\n    if (typeof logMatcher === \"string\" || logMatcher instanceof RegExp) {\n      return safeRegexpTest(logMatcher, logEntry.traceId);\n    }\n    const {\n      traceId,\n      message,\n      extra ,\n      timestamp ,\n    } = logMatcher;\n    if (isDefined(traceId) && !safeRegexpTest(traceId, logEntry.traceId)) {\n      return false;\n    }\n    if (isDefined(message) && !safeRegexpTest(message, logEntry.message)) {\n      return false;\n    }\n    if (isDefined(timestamp) && !timestamp(logEntry.timestamp)) {\n      return false;\n    }\n    if (isDefined(extra) && !extra(logEntry.extra)) {\n      return false;\n    }\n    return true;\n  };\n\nconst safeRegexpTest = (\n  regexp: string | RegExp,\n  value: string,\n  flags = \"m\"\n) => {\n  if (typeof regexp === \"string\") {\n    return safe(() => new RegExp(regexp, flags).test(value), {\n      default: false,\n      quiet: true,\n    });\n  }\n  return safe(() => regexp.test(value), {\n    default: false,\n    quiet: true,\n  });\n};\n","import { LogEntry } from \"../type/LogEntry\";\nimport { LogMatcher } from \"../type/LogMatcher\";\nimport { logMatcherMatchesLogEntry } from \"./logMatcherMatchesLogEntry\";\n\nexport const atLeastOneLogMatcherMatchesLogEntry =\n  (logMatchers: (RegExp | string | LogMatcher)[]) => (logEntry: LogEntry) => {\n    for (const logMatcher of logMatchers) {\n      if (logMatcherMatchesLogEntry(logMatcher)(logEntry)) {\n        return logMatcher;\n      }\n    }\n    return false;\n  };\n","import { LogEntry } from \"../type/LogEntry\";\nimport { LogMatcher } from \"../type/LogMatcher\";\n\nexport const transformLogEntry =\n  (matcher: RegExp | string | LogMatcher) => (logEntry: LogEntry) => {\n    if (typeof matcher === \"string\" || matcher instanceof RegExp) {\n      return logEntry;\n    }\n    if (matcher.transform) {\n      return matcher.transform(logEntry);\n    }\n    return logEntry;\n  };\n","export type MaxLengthArray<T> = {\n  length: number;\n  push: (value: T) => void;\n  get: () => T[];\n  clear: () => void;\n  last: () => T | undefined;\n};\n\nexport const MaxLengthArray = <T>(maxLength: number) => {\n  const array: T[] = [];\n\n  const mod: MaxLengthArray<T> = {\n    length: 0,\n    push: (value: T) => {\n      if (array.length >= maxLength) {\n        array.shift();\n      }\n      array.push(value);\n      mod.length = array.length;\n    },\n    get: () => {\n      return array;\n    },\n    clear: () => {\n      array.length = 0;\n      mod.length = 0;\n    },\n    last: () => {\n      return array[array.length - 1];\n    },\n  };\n\n  return mod;\n};\n","import { isDefined } from \"@mjt-engine/object\";\n\nexport type Timer = {\n  end: () => Timer;\n  getDuration: () => number;\n};\n\nexport const Timer = (): Timer => {\n  let start = performance.now();\n  let end: number | undefined;\n  const mod: Timer = {\n    end: () => {\n      if (isDefined(end)) {\n        return mod;\n      }\n      end = performance.now();\n      return mod;\n    },\n    getDuration: () => {\n      return (end ?? performance.now()) - start;\n    },\n  };\n  return mod;\n};\n","import { isDefined } from \"@mjt-engine/object\";\nimport { MaxLengthArray } from \"./MaxLengthArray\";\nimport { Timer } from \"./Timer\";\n\nexport type Stats = {\n  count: (value?: number) => void;\n  increment: (name: string, value?: number) => void;\n  gauge: (name: string, value?: number) => void;\n  timer: (name: string) => Timer;\n  time: () => Timer;\n  lastTime: () => Timer | undefined;\n  getTimes: () => Timer[];\n  getCount: () => number;\n  getCounter: (name: string) => number;\n  getCounters: () => Map<string, number>;\n  getGauge: (name: string) => number;\n  getGauges: () => Map<string, number>;\n  getTimers: (name: string) => Timer[];\n  clear: () => Stats;\n};\n\nexport const Stats = (max = 100): Stats => {\n  let count = 0;\n  const counters = new Map<string, number>();\n  const gauges = new Map<string, number>();\n  const timers = new Map<string, MaxLengthArray<Timer>>();\n  const times = MaxLengthArray<Timer>(max);\n\n  const mod: Stats = {\n    clear: () => {\n      count = 0;\n      counters.clear();\n      gauges.clear();\n      timers.clear();\n      times.clear();\n      return mod;\n    },\n    lastTime: () => {\n      return times.last();\n    },\n    time: () => {\n      const last = mod.lastTime();\n      if (isDefined(last)) {\n        last.end();\n      }\n      const timer = Timer();\n      times.push(timer);\n      return timer;\n    },\n    getTimes: () => {\n      return times.get();\n    },\n    timer: (name) => {\n      const ts = timers.get(name) ?? MaxLengthArray(max);\n      timers.set(name, ts);\n      const timer = Timer();\n      ts.push(timer);\n      return timer;\n    },\n    increment: (name: string, value: number = 1) => {\n      const current = counters.get(name) ?? 0;\n      counters.set(name, current + value);\n    },\n    gauge: (name: string, value = 0) => {\n      gauges.set(name, value);\n    },\n    getCounters: () => {\n      return new Map(counters);\n    },\n    getCounter: (name: string) => {\n      return counters.get(name) ?? 0;\n    },\n    getGauge: (name: string) => {\n      return gauges.get(name) ?? 0;\n    },\n    getGauges: () => {\n      return new Map(gauges);\n    },\n    count: (value: number = 1) => {\n      count += value;\n    },\n    getCount: () => {\n      return count;\n    },\n    getTimers: (name) => {\n      const ts = timers.get(name) ?? MaxLengthArray(max);\n      return ts.get();\n    },\n  };\n  return mod;\n};\n","import { Cache, Caches } from \"@mjt-engine/cache\";\nimport { LogEntry } from \"../type/LogEntry\";\nimport { TraceId } from \"../type/TraceId\";\nimport { LogMatcher } from \"../type/LogMatcher\";\nimport { atLeastOneLogMatcherMatchesLogEntry } from \"./atLeastOneLogMatcherMatchesLogEntry\";\nimport { transformLogEntry } from \"./transformLogEntry\";\nimport { Stats } from \"./Stats\";\n\nexport type ObserveAgent = {\n  start: (traceId: TraceId, ...extra: unknown[]) => void;\n  log: (entry: LogEntry) => void;\n  end: (traceId: TraceId, ...extra: unknown[]) => void;\n  getStats: (traceId: TraceId) => Stats;\n  getTraceIds: () => TraceId[];\n  updateLogMatchers: (\n    fn: (\n      logMatchers: (RegExp | string | LogMatcher)[]\n    ) => (string | LogMatcher)[]\n  ) => (string | LogMatcher)[];\n};\n\nexport const ObserveAgent = ({\n  logMatchers = [],\n  logger = console.log,\n  clock = performance,\n  maxSampleSize = 100,\n}: Partial<{\n  logMatchers: (string | LogMatcher)[];\n  logger: typeof console.log;\n  clock: { now: () => number };\n  maxSampleSize: number;\n}> = {}): ObserveAgent => {\n  const stats = Caches.create<Stats>();\n\n  const mod: ObserveAgent = {\n    updateLogMatchers: (fn) => {\n      const newLogMatchers = fn(logMatchers);\n      logMatchers = newLogMatchers;\n      return newLogMatchers;\n    },\n    getTraceIds: () => stats.entries().map(([traceId]) => traceId as TraceId),\n    start: (traceId, ...extra) => {\n      mod.getStats(traceId).count();\n      mod.getStats(traceId).time();\n      mod.log({ traceId, message: \"start\", extra });\n    },\n    getStats: (traceId) => stats.get(traceId, () => Stats(maxSampleSize))!,\n\n    log: ({ traceId, message, timestamp = clock.now(), extra = [] }) => {\n      const logEntry: LogEntry = {\n        traceId,\n        message,\n        timestamp,\n        extra,\n      };\n      const logMatcherMaybe =\n        atLeastOneLogMatcherMatchesLogEntry(logMatchers)(logEntry);\n      if (!logMatcherMaybe) {\n        return;\n      }\n      const transformedLogEntry = transformLogEntry(logMatcherMaybe)(logEntry);\n      logger(\n        `${transformedLogEntry.timestamp} ${transformedLogEntry.traceId}: ${transformedLogEntry.message}`,\n        ...(transformedLogEntry.extra ?? [])\n      );\n    },\n    end: (traceId, ...extra) => {\n      mod.getStats(traceId).lastTime()?.end();\n      mod.log({ traceId, message: \"end\", extra });\n    },\n  };\n  return mod;\n};\n","import { ObserveAgent } from \"../agent/ObserveAgent\";\nimport { Timer } from \"../agent/Timer\";\n\nexport type Observe = {\n  span: (spanId: string) => Observe;\n  increment: (name: string, count?: number) => Observe;\n  gauge: (name: string, value: number) => Observe;\n  timer: (name: string) => Timer;\n  sample: (probability: number, name: string, fn: () => number) => Observe;\n  when: (filter: () => boolean, name: string, fn: () => number) => Observe;\n  log: (message: string, ...extra: unknown[]) => Observe;\n  end: () => Observe;\n};\n\nexport const Observe = (\n  traceId: string = \"\",\n  agent: ObserveAgent = ObserveAgent()\n) => {\n  agent.start(traceId);\n  const mod: Observe = {\n    span: (spanId) => Observe(`${traceId}.${spanId}`, agent),\n    increment: (name, count = 1) => {\n      agent.getStats(traceId).increment(name, count);\n      return mod;\n    },\n    sample: (probability, name, fn) => {\n      if (Math.random() < probability) {\n        const value = fn();\n        mod.gauge(name, value);\n      }\n      return mod;\n    },\n    when: (filter, name, fn) => {\n      if (filter()) {\n        const value = fn();\n        mod.gauge(name, value);\n      }\n      return mod;\n    },\n    gauge: (name, value) => {\n      agent.getStats(traceId).gauge(name, value);\n      return mod;\n    },\n    timer: (name) => {\n      return agent.getStats(traceId).timer(name);\n    },\n    end: () => {\n      agent.end(traceId);\n      return mod;\n    },\n    log: (message, ...extra) => {\n      agent.log({ traceId, message, extra });\n      return mod;\n    },\n  };\n\n  return mod;\n};\n"],"names":["parseTraceId","subject","segments","root","subpath","isProducer","valueProducer","isUndefined","obj","isDefined","valueOf","Objects","producer","options","quiet","def","onError","error","safe","getCachedObject","key","map","value","product","Caches","state","lastUpdated","cache","k","v","logMatcherMatchesLogEntry","logMatcher","logEntry","safeRegexpTest","traceId","message","extra","timestamp","regexp","flags","atLeastOneLogMatcherMatchesLogEntry","logMatchers","transformLogEntry","matcher","MaxLengthArray","maxLength","array","mod","Timer","start","end","Stats","max","count","counters","gauges","timers","times","last","timer","name","ts","current","ObserveAgent","logger","clock","maxSampleSize","stats","fn","newLogMatchers","logMatcherMaybe","transformedLogEntry","Observe","agent","spanId","probability","filter"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5,6,7,8,9]}