{"version":3,"file":"index.js","sources":["../src/type/TraceId.ts","../src/agent/logMatcherMatchesLogEntry.ts","../src/agent/atLeastOneLogMatcherMatchesLogEntry.ts","../src/agent/transformLogEntry.ts","../src/agent/MaxLengthArray.ts","../src/agent/Timer.ts","../src/agent/Stats.ts","../src/agent/ObserveAgent.ts","../src/observe/Observe.ts"],"sourcesContent":["\nexport type TraceId<T extends string = string> = `${T}.${string}` | T;\n\nexport type ParsedTraceId<T extends string = string> = {\n  root: T;\n  segments: string[];\n  subpath: string;\n};\n\nexport const parseTraceId = <T extends string = string>(\n  subject: TraceId<T>\n): ParsedTraceId<T> => {\n  const segments = subject.split(\".\");\n  const root = segments.shift() as T;\n  const subpath = segments.join(\".\");\n\n  return {\n    root,\n    segments,\n    subpath,\n  };\n};\n","import { isDefined, safe } from \"@mjt-engine/object\";\nimport { LogEntry } from \"../type/LogEntry\";\nimport { LogMatcher } from \"../type/LogMatcher\";\n\nexport const logMatcherMatchesLogEntry =\n  (logMatcher: RegExp | string | LogMatcher) => (logEntry: LogEntry) => {\n    if (typeof logMatcher === \"string\" || logMatcher instanceof RegExp) {\n      return safeRegexpTest(logMatcher, logEntry.traceId);\n    }\n    const {\n      traceId,\n      message,\n      extra ,\n      timestamp ,\n    } = logMatcher;\n    if (isDefined(traceId) && !safeRegexpTest(traceId, logEntry.traceId)) {\n      return false;\n    }\n    if (isDefined(message) && !safeRegexpTest(message, logEntry.message)) {\n      return false;\n    }\n    if (isDefined(timestamp) && !timestamp(logEntry.timestamp)) {\n      return false;\n    }\n    if (isDefined(extra) && !extra(logEntry.extra)) {\n      return false;\n    }\n    return true;\n  };\n\nconst safeRegexpTest = (\n  regexp: string | RegExp,\n  value: string,\n  flags = \"m\"\n) => {\n  if (typeof regexp === \"string\") {\n    return safe(() => new RegExp(regexp, flags).test(value), {\n      default: false,\n      quiet: true,\n    });\n  }\n  return safe(() => regexp.test(value), {\n    default: false,\n    quiet: true,\n  });\n};\n","import { LogEntry } from \"../type/LogEntry\";\nimport { LogMatcher } from \"../type/LogMatcher\";\nimport { logMatcherMatchesLogEntry } from \"./logMatcherMatchesLogEntry\";\n\nexport const atLeastOneLogMatcherMatchesLogEntry =\n  (logMatchers: (RegExp | string | LogMatcher)[]) => (logEntry: LogEntry) => {\n    for (const logMatcher of logMatchers) {\n      if (logMatcherMatchesLogEntry(logMatcher)(logEntry)) {\n        return logMatcher;\n      }\n    }\n    return false;\n  };\n","import { LogEntry } from \"../type/LogEntry\";\nimport { LogMatcher } from \"../type/LogMatcher\";\n\nexport const transformLogEntry =\n  (matcher: RegExp | string | LogMatcher) => (logEntry: LogEntry) => {\n    if (typeof matcher === \"string\" || matcher instanceof RegExp) {\n      return logEntry;\n    }\n    if (matcher.transform) {\n      return matcher.transform(logEntry);\n    }\n    return logEntry;\n  };\n","export type MaxLengthArray<T> = {\n  length: number;\n  push: (value: T) => void;\n  get: () => T[];\n  clear: () => void;\n  last: () => T | undefined;\n};\n\nexport const MaxLengthArray = <T>(maxLength: number) => {\n  const array: T[] = [];\n\n  const mod: MaxLengthArray<T> = {\n    length: 0,\n    push: (value: T) => {\n      if (array.length >= maxLength) {\n        array.shift();\n      }\n      array.push(value);\n      mod.length = array.length;\n    },\n    get: () => {\n      return array;\n    },\n    clear: () => {\n      array.length = 0;\n      mod.length = 0;\n    },\n    last: () => {\n      return array[array.length - 1];\n    },\n  };\n\n  return mod;\n};\n","import { isDefined } from \"@mjt-engine/object\";\n\nexport type Timer = {\n  end: () => Timer;\n  getDuration: () => number;\n};\n\nexport const Timer = (): Timer => {\n  let start = performance.now();\n  let end: number | undefined;\n  const mod: Timer = {\n    end: () => {\n      if (isDefined(end)) {\n        return mod;\n      }\n      end = performance.now();\n      return mod;\n    },\n    getDuration: () => {\n      return (end ?? performance.now()) - start;\n    },\n  };\n  return mod;\n};\n","import { isDefined } from \"@mjt-engine/object\";\nimport { MaxLengthArray } from \"./MaxLengthArray\";\nimport { Timer } from \"./Timer\";\n\nexport type Stats = {\n  count: (value?: number) => void;\n  increment: (name: string, value?: number) => void;\n  gauge: (name: string, value?: number) => void;\n  timer: (name: string) => Timer;\n  time: () => Timer;\n  lastTime: () => Timer | undefined;\n  getTimes: () => Timer[];\n  getCount: () => number;\n  getCounter: (name: string) => number;\n  getCounters: () => Map<string, number>;\n  getGauge: (name: string) => number;\n  getGauges: () => Map<string, number>;\n  getTimers: (name: string) => Timer[];\n  clear: () => Stats;\n};\n\nexport const Stats = (max = 100): Stats => {\n  let count = 0;\n  const counters = new Map<string, number>();\n  const gauges = new Map<string, number>();\n  const timers = new Map<string, MaxLengthArray<Timer>>();\n  const times = MaxLengthArray<Timer>(max);\n\n  const mod: Stats = {\n    clear: () => {\n      count = 0;\n      counters.clear();\n      gauges.clear();\n      timers.clear();\n      times.clear();\n      return mod;\n    },\n    lastTime: () => {\n      return times.last();\n    },\n    time: () => {\n      const last = mod.lastTime();\n      if (isDefined(last)) {\n        last.end();\n      }\n      const timer = Timer();\n      times.push(timer);\n      return timer;\n    },\n    getTimes: () => {\n      return times.get();\n    },\n    timer: (name) => {\n      const ts = timers.get(name) ?? MaxLengthArray(max);\n      timers.set(name, ts);\n      const timer = Timer();\n      ts.push(timer);\n      return timer;\n    },\n    increment: (name: string, value: number = 1) => {\n      const current = counters.get(name) ?? 0;\n      counters.set(name, current + value);\n    },\n    gauge: (name: string, value = 0) => {\n      gauges.set(name, value);\n    },\n    getCounters: () => {\n      return new Map(counters);\n    },\n    getCounter: (name: string) => {\n      return counters.get(name) ?? 0;\n    },\n    getGauge: (name: string) => {\n      return gauges.get(name) ?? 0;\n    },\n    getGauges: () => {\n      return new Map(gauges);\n    },\n    count: (value: number = 1) => {\n      count += value;\n    },\n    getCount: () => {\n      return count;\n    },\n    getTimers: (name) => {\n      const ts = timers.get(name) ?? MaxLengthArray(max);\n      return ts.get();\n    },\n  };\n  return mod;\n};\n","import { Cache, Caches } from \"@mjt-engine/cache\";\nimport { LogEntry } from \"../type/LogEntry\";\nimport { TraceId } from \"../type/TraceId\";\nimport { LogMatcher } from \"../type/LogMatcher\";\nimport { atLeastOneLogMatcherMatchesLogEntry } from \"./atLeastOneLogMatcherMatchesLogEntry\";\nimport { transformLogEntry } from \"./transformLogEntry\";\nimport { Stats } from \"./Stats\";\n\nexport type ObserveAgent = {\n  start: (traceId: TraceId, ...extra: unknown[]) => void;\n  log: (entry: LogEntry) => void;\n  end: (traceId: TraceId, ...extra: unknown[]) => void;\n  getStats: (traceId: TraceId) => Stats;\n  getTraceIds: () => TraceId[];\n  updateLogMatchers: (\n    fn: (\n      logMatchers: (RegExp | string | LogMatcher)[]\n    ) => (string | LogMatcher)[]\n  ) => (string | LogMatcher)[];\n};\n\nexport const ObserveAgent = ({\n  logMatchers = [],\n  logger = console.log,\n  clock = performance,\n  maxSampleSize = 100,\n}: Partial<{\n  logMatchers: (string | LogMatcher)[];\n  logger: typeof console.log;\n  clock: { now: () => number };\n  maxSampleSize: number;\n}> = {}): ObserveAgent => {\n  const stats = Caches.create<Stats>();\n\n  const mod: ObserveAgent = {\n    updateLogMatchers: (fn) => {\n      const newLogMatchers = fn(logMatchers);\n      logMatchers = newLogMatchers;\n      return newLogMatchers;\n    },\n    getTraceIds: () => stats.entries().map(([traceId]) => traceId as TraceId),\n    start: (traceId, ...extra) => {\n      mod.getStats(traceId).count();\n      mod.getStats(traceId).time();\n    },\n    getStats: (traceId) => stats.get(traceId, () => Stats(maxSampleSize))!,\n\n    log: ({ traceId, message, timestamp = clock.now(), extra = [] }) => {\n      const logEntry: LogEntry = {\n        traceId,\n        message,\n        timestamp,\n        extra,\n      };\n      const logMatcherMaybe =\n        atLeastOneLogMatcherMatchesLogEntry(logMatchers)(logEntry);\n      if (!logMatcherMaybe) {\n        return;\n      }\n      const transformedLogEntry = transformLogEntry(logMatcherMaybe)(logEntry);\n      logger(\n        `${transformedLogEntry.timestamp} ${transformedLogEntry.traceId}: ${transformedLogEntry.message}`,\n        ...(transformedLogEntry.extra ?? [])\n      );\n    },\n    end: (traceId, ...extra) => {\n      mod.getStats(traceId).lastTime()?.end();\n    },\n  };\n  return mod;\n};\n","import { ObserveAgent } from \"../agent/ObserveAgent\";\nimport { Timer } from \"../agent/Timer\";\n\nexport type Observe = {\n  span: (spanId: string) => Observe;\n  increment: (name: string, count?: number) => Observe;\n  gauge: (name: string, value: number) => Observe;\n  timer: (name: string) => Timer;\n  sample: (probability: number, name: string, fn: () => number) => Observe;\n  when: (filter: () => boolean, name: string, fn: () => number) => Observe;\n  log: (message: string, ...extra: unknown[]) => Observe;\n  end: () => Observe;\n};\n\nexport const Observe = (\n  traceId: string = \"\",\n  agent: ObserveAgent = ObserveAgent()\n) => {\n  agent.start(traceId);\n  const mod: Observe = {\n    span: (spanId) => Observe(`${traceId}.${spanId}`, agent),\n    increment: (name, count = 1) => {\n      agent.getStats(traceId).increment(name, count);\n      return mod;\n    },\n    sample: (probability, name, fn) => {\n      if (Math.random() < probability) {\n        const value = fn();\n        mod.gauge(name, value);\n      }\n      return mod;\n    },\n    when: (filter, name, fn) => {\n      if (filter()) {\n        const value = fn();\n        mod.gauge(name, value);\n      }\n      return mod;\n    },\n    gauge: (name, value) => {\n      agent.getStats(traceId).gauge(name, value);\n      return mod;\n    },\n    timer: (name) => {\n      return agent.getStats(traceId).timer(name);\n    },\n    end: () => {\n      agent.end(traceId);\n      return mod;\n    },\n    log: (message, ...extra) => {\n      agent.log({ traceId, message, extra });\n      return mod;\n    },\n  };\n\n  return mod;\n};\n"],"names":["parseTraceId","subject","segments","root","subpath","logMatcherMatchesLogEntry","logMatcher","logEntry","safeRegexpTest","traceId","message","extra","timestamp","isDefined","regexp","value","flags","safe","atLeastOneLogMatcherMatchesLogEntry","logMatchers","transformLogEntry","matcher","MaxLengthArray","maxLength","array","mod","Timer","start","end","Stats","max","count","counters","gauges","timers","times","last","timer","name","ts","current","ObserveAgent","logger","clock","maxSampleSize","stats","Caches","fn","newLogMatchers","logMatcherMaybe","transformedLogEntry","Observe","agent","spanId","probability","filter"],"mappings":";;AASa,MAAAA,IAAe,CAC1BC,MACqB;AACf,QAAAC,IAAWD,EAAQ,MAAM,GAAG,GAC5BE,IAAOD,EAAS,MAAM,GACtBE,IAAUF,EAAS,KAAK,GAAG;AAE1B,SAAA;AAAA,IACL,MAAAC;AAAA,IACA,UAAAD;AAAA,IACA,SAAAE;AAAA,EACF;AACF,GCjBaC,IACX,CAACC,MAA6C,CAACC,MAAuB;AACpE,MAAI,OAAOD,KAAe,YAAYA,aAAsB;AACnD,WAAAE,EAAeF,GAAYC,EAAS,OAAO;AAE9C,QAAA;AAAA,IACJ,SAAAE;AAAA,IACA,SAAAC;AAAA,IACA,OAAAC;AAAA,IACA,WAAAC;AAAA,EAAA,IACEN;AAUJ,SATI,EAAAO,EAAUJ,CAAO,KAAK,CAACD,EAAeC,GAASF,EAAS,OAAO,KAG/DM,EAAUH,CAAO,KAAK,CAACF,EAAeE,GAASH,EAAS,OAAO,KAG/DM,EAAUD,CAAS,KAAK,CAACA,EAAUL,EAAS,SAAS,KAGrDM,EAAUF,CAAK,KAAK,CAACA,EAAMJ,EAAS,KAAK;AAI/C,GAEIC,IAAiB,CACrBM,GACAC,GACAC,IAAQ,QAEJ,OAAOF,KAAW,WACbG,EAAK,MAAM,IAAI,OAAOH,GAAQE,CAAK,EAAE,KAAKD,CAAK,GAAG;AAAA,EACvD,SAAS;AAAA,EACT,OAAO;AAAA,CACR,IAEIE,EAAK,MAAMH,EAAO,KAAKC,CAAK,GAAG;AAAA,EACpC,SAAS;AAAA,EACT,OAAO;AAAA,CACR,GCxCUG,IACX,CAACC,MAAkD,CAACZ,MAAuB;AACzE,aAAWD,KAAca;AACvB,QAAId,EAA0BC,CAAU,EAAEC,CAAQ;AACzC,aAAAD;AAGJ,SAAA;AACT,GCTWc,IACX,CAACC,MAA0C,CAACd,MACtC,OAAOc,KAAY,YAAYA,aAAmB,SAC7Cd,IAELc,EAAQ,YACHA,EAAQ,UAAUd,CAAQ,IAE5BA,GCHEe,IAAiB,CAAIC,MAAsB;AACtD,QAAMC,IAAa,CAAC,GAEdC,IAAyB;AAAA,IAC7B,QAAQ;AAAA,IACR,MAAM,CAACV,MAAa;AACd,MAAAS,EAAM,UAAUD,KAClBC,EAAM,MAAM,GAEdA,EAAM,KAAKT,CAAK,GAChBU,EAAI,SAASD,EAAM;AAAA,IACrB;AAAA,IACA,KAAK,MACIA;AAAA,IAET,OAAO,MAAM;AACX,MAAAA,EAAM,SAAS,GACfC,EAAI,SAAS;AAAA,IACf;AAAA,IACA,MAAM,MACGD,EAAMA,EAAM,SAAS,CAAC;AAAA,EAEjC;AAEO,SAAAC;AACT,GC1BaC,IAAQ,MAAa;AAC5B,MAAAC,IAAQ,YAAY,IAAI,GACxBC;AACJ,QAAMH,IAAa;AAAA,IACjB,KAAK,OACCZ,EAAUe,CAAG,MAGjBA,IAAM,YAAY,IAAI,IACfH;AAAA,IAET,aAAa,OACHG,KAAO,YAAY,IAAS,KAAAD;AAAA,EAExC;AACO,SAAAF;AACT,GCFaI,IAAQ,CAACC,IAAM,QAAe;AACzC,MAAIC,IAAQ;AACN,QAAAC,wBAAe,IAAoB,GACnCC,wBAAa,IAAoB,GACjCC,wBAAa,IAAmC,GAChDC,IAAQb,EAAsBQ,CAAG,GAEjCL,IAAa;AAAA,IACjB,OAAO,OACGM,IAAA,GACRC,EAAS,MAAM,GACfC,EAAO,MAAM,GACbC,EAAO,MAAM,GACbC,EAAM,MAAM,GACLV;AAAA,IAET,UAAU,MACDU,EAAM,KAAK;AAAA,IAEpB,MAAM,MAAM;AACJ,YAAAC,IAAOX,EAAI,SAAS;AACtB,MAAAZ,EAAUuB,CAAI,KAChBA,EAAK,IAAI;AAEX,YAAMC,IAAQX,EAAM;AACpB,aAAAS,EAAM,KAAKE,CAAK,GACTA;AAAA,IACT;AAAA,IACA,UAAU,MACDF,EAAM,IAAI;AAAA,IAEnB,OAAO,CAACG,MAAS;AACf,YAAMC,IAAKL,EAAO,IAAII,CAAI,KAAKhB,EAAeQ,CAAG;AAC1C,MAAAI,EAAA,IAAII,GAAMC,CAAE;AACnB,YAAMF,IAAQX,EAAM;AACpB,aAAAa,EAAG,KAAKF,CAAK,GACNA;AAAA,IACT;AAAA,IACA,WAAW,CAACC,GAAcvB,IAAgB,MAAM;AAC9C,YAAMyB,IAAUR,EAAS,IAAIM,CAAI,KAAK;AAC7B,MAAAN,EAAA,IAAIM,GAAME,IAAUzB,CAAK;AAAA,IACpC;AAAA,IACA,OAAO,CAACuB,GAAcvB,IAAQ,MAAM;AAC3B,MAAAkB,EAAA,IAAIK,GAAMvB,CAAK;AAAA,IACxB;AAAA,IACA,aAAa,MACJ,IAAI,IAAIiB,CAAQ;AAAA,IAEzB,YAAY,CAACM,MACJN,EAAS,IAAIM,CAAI,KAAK;AAAA,IAE/B,UAAU,CAACA,MACFL,EAAO,IAAIK,CAAI,KAAK;AAAA,IAE7B,WAAW,MACF,IAAI,IAAIL,CAAM;AAAA,IAEvB,OAAO,CAAClB,IAAgB,MAAM;AACnB,MAAAgB,KAAAhB;AAAA,IACX;AAAA,IACA,UAAU,MACDgB;AAAA,IAET,WAAW,CAACO,OACCJ,EAAO,IAAII,CAAI,KAAKhB,EAAeQ,CAAG,GACvC,IAAI;AAAA,EAElB;AACO,SAAAL;AACT,GCrEagB,IAAe,CAAC;AAAA,EAC3B,aAAAtB,IAAc,CAAC;AAAA,EACf,QAAAuB,IAAS,QAAQ;AAAA,EACjB,OAAAC,IAAQ;AAAA,EACR,eAAAC,IAAgB;AAClB,IAKK,OAAqB;AAClB,QAAAC,IAAQC,EAAO,OAAc,GAE7BrB,IAAoB;AAAA,IACxB,mBAAmB,CAACsB,MAAO;AACnB,YAAAC,IAAiBD,EAAG5B,CAAW;AACvB,aAAAA,IAAA6B,GACPA;AAAA,IACT;AAAA,IACA,aAAa,MAAMH,EAAM,QAAQ,EAAE,IAAI,CAAC,CAACpC,CAAO,MAAMA,CAAkB;AAAA,IACxE,OAAO,CAACA,MAAYE,MAAU;AACxB,MAAAc,EAAA,SAAShB,CAAO,EAAE,MAAM,GACxBgB,EAAA,SAAShB,CAAO,EAAE,KAAK;AAAA,IAC7B;AAAA,IACA,UAAU,CAACA,MAAYoC,EAAM,IAAIpC,GAAS,MAAMoB,EAAMe,CAAa,CAAC;AAAA,IAEpE,KAAK,CAAC,EAAE,SAAAnC,GAAS,SAAAC,GAAS,WAAAE,IAAY+B,EAAM,IAAO,GAAA,OAAAhC,IAAQ,CAAA,QAAS;AAClE,YAAMJ,IAAqB;AAAA,QACzB,SAAAE;AAAA,QACA,SAAAC;AAAA,QACA,WAAAE;AAAA,QACA,OAAAD;AAAA,MACF,GACMsC,IACJ/B,EAAoCC,CAAW,EAAEZ,CAAQ;AAC3D,UAAI,CAAC0C;AACH;AAEF,YAAMC,IAAsB9B,EAAkB6B,CAAe,EAAE1C,CAAQ;AACvE,MAAAmC;AAAA,QACE,GAAGQ,EAAoB,SAAS,IAAIA,EAAoB,OAAO,KAAKA,EAAoB,OAAO;AAAA,QAC/F,GAAIA,EAAoB,SAAS,CAAA;AAAA,MACnC;AAAA,IACF;AAAA,IACA,KAAK,CAACzC,MAAYE,MAAU;AAC1B,MAAAc,EAAI,SAAShB,CAAO,EAAE,SAAA,GAAY,IAAI;AAAA,IAAA;AAAA,EAE1C;AACO,SAAAgB;AACT,GCxDa0B,IAAU,CACrB1C,IAAkB,IAClB2C,IAAsBX,QACnB;AACH,EAAAW,EAAM,MAAM3C,CAAO;AACnB,QAAMgB,IAAe;AAAA,IACnB,MAAM,CAAC4B,MAAWF,EAAQ,GAAG1C,CAAO,IAAI4C,CAAM,IAAID,CAAK;AAAA,IACvD,WAAW,CAACd,GAAMP,IAAQ,OACxBqB,EAAM,SAAS3C,CAAO,EAAE,UAAU6B,GAAMP,CAAK,GACtCN;AAAA,IAET,QAAQ,CAAC6B,GAAahB,GAAMS,MAAO;AAC7B,UAAA,KAAK,OAAO,IAAIO,GAAa;AAC/B,cAAMvC,IAAQgC,EAAG;AACb,QAAAtB,EAAA,MAAMa,GAAMvB,CAAK;AAAA,MAAA;AAEhB,aAAAU;AAAA,IACT;AAAA,IACA,MAAM,CAAC8B,GAAQjB,GAAMS,MAAO;AAC1B,UAAIQ,KAAU;AACZ,cAAMxC,IAAQgC,EAAG;AACb,QAAAtB,EAAA,MAAMa,GAAMvB,CAAK;AAAA,MAAA;AAEhB,aAAAU;AAAA,IACT;AAAA,IACA,OAAO,CAACa,GAAMvB,OACZqC,EAAM,SAAS3C,CAAO,EAAE,MAAM6B,GAAMvB,CAAK,GAClCU;AAAA,IAET,OAAO,CAACa,MACCc,EAAM,SAAS3C,CAAO,EAAE,MAAM6B,CAAI;AAAA,IAE3C,KAAK,OACHc,EAAM,IAAI3C,CAAO,GACVgB;AAAA,IAET,KAAK,CAACf,MAAYC,OAChByC,EAAM,IAAI,EAAE,SAAA3C,GAAS,SAAAC,GAAS,OAAAC,GAAO,GAC9Bc;AAAA,EAEX;AAEO,SAAAA;AACT;"}