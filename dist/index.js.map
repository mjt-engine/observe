{"version":3,"file":"index.js","sources":["../src/type/TraceId.ts","../node_modules/.pnpm/@mjt-engine+object@https+++codeload.github.com+mjt-engine+object+tar.gz+cf5530e63f97f9ecf37d8b32674818b5c0c614fd/node_modules/@mjt-engine/object/dist/object/type/Producer.js","../node_modules/.pnpm/@mjt-engine+object@https+++codeload.github.com+mjt-engine+object+tar.gz+cf5530e63f97f9ecf37d8b32674818b5c0c614fd/node_modules/@mjt-engine/object/dist/object/isUndefined.js","../node_modules/.pnpm/@mjt-engine+object@https+++codeload.github.com+mjt-engine+object+tar.gz+cf5530e63f97f9ecf37d8b32674818b5c0c614fd/node_modules/@mjt-engine/object/dist/object/isDefined.js","../node_modules/.pnpm/@mjt-engine+object@https+++codeload.github.com+mjt-engine+object+tar.gz+cf5530e63f97f9ecf37d8b32674818b5c0c614fd/node_modules/@mjt-engine/object/dist/object/valueOf.js","../node_modules/.pnpm/@mjt-engine+object@https+++codeload.github.com+mjt-engine+object+tar.gz+cf5530e63f97f9ecf37d8b32674818b5c0c614fd/node_modules/@mjt-engine/object/dist/object/safe.js","../node_modules/.pnpm/@mjt-engine+object@https+++codeload.github.com+mjt-engine+object+tar.gz+cf5530e63f97f9ecf37d8b32674818b5c0c614fd/node_modules/@mjt-engine/object/dist/object/Objects.js","../node_modules/.pnpm/@mjt-engine+object@https+++codeload.github.com+mjt-engine+object+tar.gz+cf5530e63f97f9ecf37d8b32674818b5c0c614fd/node_modules/@mjt-engine/object/dist/index.js","../node_modules/.pnpm/@mjt-engine+cache@https+++codeload.github.com+mjt-engine+cache+tar.gz+1f7dba33f49bce1a232d2c147441579f026512a5/node_modules/@mjt-engine/cache/dist/cache/getCachedObject.js","../node_modules/.pnpm/@mjt-engine+cache@https+++codeload.github.com+mjt-engine+cache+tar.gz+1f7dba33f49bce1a232d2c147441579f026512a5/node_modules/@mjt-engine/cache/dist/cache/Caches.js","../src/agent/logMatcherMatchesLogEntry.ts","../src/agent/atLeastOneLogMatcherMatchesLogEntry.ts","../src/agent/transformLogEntry.ts","../src/agent/MaxLengthArray.ts","../src/agent/Timer.ts","../src/agent/Stats.ts","../src/agent/ObserveAgent.ts","../src/observe/Observe.ts"],"sourcesContent":["\nexport type TraceId<T extends string = string> = `${T}.${string}` | T;\n\nexport type ParsedTraceId<T extends string = string> = {\n  root: T;\n  segments: string[];\n  subpath: string;\n};\n\nexport const parseTraceId = <T extends string = string>(\n  subject: TraceId<T>\n): ParsedTraceId<T> => {\n  const segments = subject.split(\".\");\n  const root = segments.shift() as T;\n  const subpath = segments.join(\".\");\n\n  return {\n    root,\n    segments,\n    subpath,\n  };\n};\n","export const isProducer = (valueProducer) => {\n    return typeof valueProducer === \"function\";\n};\n//# sourceMappingURL=Producer.js.map","export const isUndefined = (obj) => {\n    return obj === undefined || obj === null || Number.isNaN(obj);\n};\n//# sourceMappingURL=isUndefined.js.map","import { isUndefined } from \"./isUndefined\";\nexport const isDefined = (obj) => {\n    return !isUndefined(obj);\n};\n//# sourceMappingURL=isDefined.js.map","import { isProducer } from \"./type/Producer\";\nexport const valueOf = (valueProducer) => {\n    if (isProducer(valueProducer)) {\n        return valueProducer();\n    }\n    return valueProducer;\n};\n//# sourceMappingURL=valueOf.js.map","import { isDefined } from \"./isDefined\";\nimport { valueOf } from \"./valueOf\";\nexport const safe = (producer, options = {}) => {\n    const { quiet = false, default: def = undefined, onError } = options;\n    try {\n        return producer();\n    }\n    catch (error) {\n        if (!quiet) {\n            console.error(error);\n            if (isDefined(onError)) {\n                console.log(valueOf(onError));\n            }\n        }\n        return def;\n    }\n};\n//# sourceMappingURL=safe.js.map","import { chain } from \"./chain\";\nimport { entries } from \"./entries\";\nimport { filter } from \"./filter\";\nimport { first } from \"./first\";\nimport { fix } from \"./fix/fix\";\nimport { forEach } from \"./forEach\";\nimport { freeze } from \"./freeze\";\nimport { fromEntries } from \"./fromEntries\";\nimport { fromEntriesToMultimap } from \"./fromEntriesToMultimap\";\nimport { get } from \"./get\";\nimport { hasKey } from \"./hasKey\";\nimport { headOf } from \"./headOf\";\nimport { iff } from \"./iff\";\nimport { iffBrowser } from \"./iffBrowser\";\nimport { iffTyped } from \"./iffTyped\";\nimport { includesUndefined } from \"./includesUndefined\";\nimport { isBrowser } from \"./isBrowser\";\nimport { isDefined } from \"./isDefined\";\nimport { isEmpty } from \"./isEmpty\";\nimport { isNotEmpty } from \"./isNotEmpty\";\nimport { isUndefined } from \"./isUndefined\";\nimport { keys } from \"./keys\";\nimport { last } from \"./last\";\nimport { mapValue } from \"./map\";\nimport { mapOf } from \"./mapOf\";\nimport { omit, omitUnsafe } from \"./omit\";\nimport { orElse } from \"./orElse\";\nimport { orError } from \"./orError\";\nimport { removeUndefinedValues } from \"./removeUndefinedValues\";\nimport { restOf } from \"./restOf\";\nimport { safe } from \"./safe\";\nimport { safeAsync } from \"./safeAsync\";\nimport { set, setUnsafe } from \"./set\";\nimport { tailOf } from \"./tailOf\";\nimport { times } from \"./times\";\nimport { timesGen } from \"./timesGen\";\nimport { toBoolean } from \"./toBoolean\";\nimport { toMany } from \"./toMany\";\nimport { toMultiMap } from \"./toMultiMap\";\nimport { toNumber } from \"./toNumber\";\nimport { toPromise } from \"./toPromise\";\nimport { tryValue } from \"./tryValue\";\nimport { tuple0, tuple1, tuple2, tuple3, tuple4, tuple5 } from \"./tuples\";\nimport { isArrayLike } from \"./type/isArrayLike\";\nimport { isErrorLike } from \"./type/isErrorLike\";\nimport { isErrorType } from \"./type/isErrorType\";\nimport { isFunction } from \"./type/isFunction\";\nimport { isIterable } from \"./type/isIterable\";\nimport { isIterator } from \"./type/isIterator\";\nimport { update, updateUnsafe } from \"./update\";\nimport { valueOf } from \"./valueOf\";\nimport { values } from \"./values\";\nimport { waitTimeout } from \"./waitTimeout\";\nimport { createSettler } from \"./createSettler\";\nimport { parseIncompleteJson } from \"./parseIncompleteJson\";\nimport { lengthOf } from \"./lengthOf\";\nexport const Objects = {\n    lengthOf,\n    isErrorLike,\n    orError,\n    tryValue,\n    isErrorType,\n    isEmpty,\n    isNotEmpty,\n    isIterator,\n    isArrayLike,\n    times,\n    first,\n    last,\n    fix,\n    iff,\n    iffTyped,\n    includesUndefined,\n    isDefined,\n    isUndefined,\n    omit,\n    omitUnsafe,\n    orElse,\n    removeUndefinedValues,\n    toMany,\n    set,\n    setUnsafe,\n    get,\n    update,\n    updateUnsafe,\n    entries,\n    keys,\n    values,\n    forEach,\n    filter,\n    chain,\n    fromEntries,\n    fromEntriesToMultimap,\n    freeze,\n    hasKey,\n    tuple0,\n    tuple1,\n    tuple2,\n    tuple3,\n    tuple4,\n    tuple5,\n    safe,\n    safeAsync,\n    valueOf,\n    mapValue,\n    headOf,\n    tailOf,\n    restOf,\n    toMultiMap,\n    timesGen,\n    isIterable,\n    isBrowser,\n    iffBrowser,\n    mapOf,\n    toPromise,\n    all: Promise.all,\n    isFunction,\n    toNumber,\n    toBoolean,\n    waitTimeout,\n    createSettler,\n    parseIncompleteJson,\n};\nexport * from \"./tuples\";\n//# sourceMappingURL=Objects.js.map","export * from \"./object/brand/type/Brand\";\nexport * from \"./object/type/ErrorLike\";\nexport * from \"./object/type/Nullable\";\nexport * from \"./object/type/Producer\";\nexport * from \"./object/type/TypeGuard\";\nexport * from \"./object/type/Indexable\";\nexport * from \"./object/type/Indexable\";\nexport * from \"./object/type/TypedArray\";\nexport * from \"./object/Arrays\";\nexport * from \"./object/Objects\";\nexport * from \"./object/fix/Fixes\";\nexport * from \"./object/fix/extend\";\nexport * from \"./object/fix/fix\";\nexport * from \"./object/fix/fixArray\";\nexport * from \"./object/fix/fixObject\";\nexport * from \"./object/fix/type/Fixed\";\nimport { Objects } from \"./object/Objects\";\nexport * from \"./key/Keys\";\nexport * from \"./object/typebox/TypeBoxes\";\nexport const { lengthOf, isErrorLike, chain, entries, filter, first, last, forEach, iff, orElse, removeUndefinedValues, iffTyped, isDefined, isUndefined, omit, omitUnsafe, toMany, fromEntries, safe, safeAsync, mapValue, headOf, tailOf, restOf, times, isIterator, toMultiMap, timesGen, isIterable, isArrayLike, iffBrowser, isBrowser, toPromise, all, isFunction, isEmpty, isNotEmpty, tryValue, orError, isErrorType, createSettler, } = Objects;\n//# sourceMappingURL=index.js.map","import { isDefined, isUndefined } from \"@mjt-engine/object\";\nexport const getCachedObject = (key, map, producer) => {\n    if (isUndefined(key)) {\n        return undefined;\n    }\n    const value = map.get(key);\n    if (isDefined(value)) {\n        return value;\n    }\n    if (isDefined(producer)) {\n        const product = producer();\n        map.set(key, product);\n        return product;\n    }\n    return undefined;\n};\n//# sourceMappingURL=getCachedObject.js.map","import { getCachedObject } from \"./getCachedObject\";\nconst create = () => {\n    const state = new Map();\n    let lastUpdated = performance.now();\n    const cache = {\n        get: (key, producer) => getCachedObject(key, state, producer),\n        set: (key, value) => {\n            state.set(key, value);\n            return cache;\n        },\n        delete: (key) => {\n            return state.delete(key);\n        },\n        entries: () => Array.from(state.entries()),\n        clear: () => state.clear(),\n        size: () => state.size,\n        findKeys: (value) => {\n            const entries = Array.from(state.entries());\n            return entries.filter(([k, v]) => v === value).map(([k, v]) => k);\n        },\n        lastUpdate: () => lastUpdated,\n    };\n    return cache;\n};\nexport const Caches = {\n    create,\n};\n//# sourceMappingURL=Caches.js.map","import { safe } from \"@mjt-engine/object\";\nimport { LogEntry } from \"../type/LogEntry\";\nimport { LogMatcher } from \"./LogMatcher\";\n\nexport const logMatcherMatchesLogEntry =\n  (logMatcher: string | LogMatcher) => (logEntry: LogEntry) => {\n    if (typeof logMatcher === \"string\") {\n      return safe(() => new RegExp(logMatcher).test(logEntry.traceId), {\n        default: false,\n      });\n    }\n    const {\n      traceId,\n      message,\n      extra = () => true,\n      timestamp = () => true,\n    } = logMatcher;\n    if (traceId && !new RegExp(traceId).test(logEntry.traceId)) {\n      return false;\n    }\n    if (message && !new RegExp(message).test(logEntry.message)) {\n      return false;\n    }\n    if (logEntry.timestamp && !timestamp(logEntry.timestamp)) {\n      return false;\n    }\n    if (logEntry.extra && !extra(logEntry.extra)) {\n      return false;\n    }\n    return true;\n  };\n","import { LogEntry } from \"../type/LogEntry\";\nimport { LogMatcher } from \"./LogMatcher\";\nimport { logMatcherMatchesLogEntry } from \"./logMatcherMatchesLogEntry\";\n\n\nexport const atLeastOneLogMatcherMatchesLogEntry = (logMatchers: (string | LogMatcher)[]) => (logEntry: LogEntry) => {\n  for (const logMatcher of logMatchers) {\n    if (logMatcherMatchesLogEntry(logMatcher)(logEntry)) {\n      return logMatcher;\n    }\n  }\n  return false;\n};\n","import { LogEntry } from \"../type/LogEntry\";\nimport { LogMatcher } from \"./LogMatcher\";\n\n\nexport const transformLogEntry = (matcher: string | LogMatcher) => (logEntry: LogEntry) => {\n  if (typeof matcher === \"string\") {\n    return logEntry;\n  }\n  if (matcher.transform) {\n    return matcher.transform(logEntry);\n  }\n  return logEntry;\n};\n","export type MaxLengthArray<T> = {\n  length: number;\n  push: (value: T) => void;\n  get: () => T[];\n  clear: () => void;\n  last: () => T | undefined;\n};\n\nexport const MaxLengthArray = <T>(maxLength: number) => {\n  const array: T[] = [];\n\n  const mod: MaxLengthArray<T> = {\n    length: 0,\n    push: (value: T) => {\n      if (array.length >= maxLength) {\n        array.shift();\n      }\n      array.push(value);\n      mod.length = array.length;\n    },\n    get: () => {\n      return array;\n    },\n    clear: () => {\n      array.length = 0;\n      mod.length = 0;\n    },\n    last: () => {\n      return array[array.length - 1];\n    },\n  };\n\n  return mod;\n};\n","import { isDefined } from \"@mjt-engine/object\";\n\nexport type Timer = {\n  end: () => Timer;\n  getDuration: () => number;\n};\n\nexport const Timer = (): Timer => {\n  let start = performance.now();\n  let end: number | undefined;\n  const mod: Timer = {\n    end: () => {\n      if (isDefined(end)) {\n        return mod;\n      }\n      end = performance.now();\n      return mod;\n    },\n    getDuration: () => {\n      return (end ?? performance.now()) - start;\n    },\n  };\n  return mod;\n};\n","import { isDefined } from \"@mjt-engine/object\";\nimport { MaxLengthArray } from \"./MaxLengthArray\";\nimport { Timer } from \"./Timer\";\n\nexport type Stats = {\n  count: (value?: number) => void;\n  increment: (name: string, value?: number) => void;\n  gauge: (name: string, value?: number) => void;\n  timer: (name: string) => Timer;\n  time: () => Timer;\n  lastTime: () => Timer | undefined;\n  getTimes: () => Timer[];\n  getCount: () => number;\n  getCounter: (name: string) => number;\n  getCounters: () => Map<string, number>;\n  getGauge: (name: string) => number;\n  getGauges: () => Map<string, number>;\n  getTimers: (name: string) => Timer[];\n  clear: () => Stats;\n};\n\nexport const Stats = (max = 100): Stats => {\n  let count = 0;\n  const counters = new Map<string, number>();\n  const gauges = new Map<string, number>();\n  const timers = new Map<string, MaxLengthArray<Timer>>();\n  const times = MaxLengthArray<Timer>(max);\n\n  const mod: Stats = {\n    clear: () => {\n      count = 0;\n      counters.clear();\n      gauges.clear();\n      timers.clear();\n      times.clear();\n      return mod;\n    },\n    lastTime: () => {\n      return times.last();\n    },\n    time: () => {\n      const last = mod.lastTime();\n      if (isDefined(last)) {\n        last.end();\n      }\n      const timer = Timer();\n      times.push(timer);\n      return timer;\n    },\n    getTimes: () => {\n      return times.get();\n    },\n    timer: (name) => {\n      const ts = timers.get(name) ?? MaxLengthArray(max);\n      timers.set(name, ts);\n      const timer = Timer();\n      ts.push(timer);\n      return timer;\n    },\n    increment: (name: string, value: number = 1) => {\n      const current = counters.get(name) ?? 0;\n      counters.set(name, current + value);\n    },\n    gauge: (name: string, value = 0) => {\n      gauges.set(name, value);\n    },\n    getCounters: () => {\n      return new Map(counters);\n    },\n    getCounter: (name: string) => {\n      return counters.get(name) ?? 0;\n    },\n    getGauge: (name: string) => {\n      return gauges.get(name) ?? 0;\n    },\n    getGauges: () => {\n      return new Map(gauges);\n    },\n    count: (value: number = 1) => {\n      count += value;\n    },\n    getCount: () => {\n      return count;\n    },\n    getTimers: (name) => {\n      const ts = timers.get(name) ?? MaxLengthArray(max);\n      return ts.get();\n    },\n  };\n  return mod;\n};\n","import { Cache, Caches } from \"@mjt-engine/cache\";\nimport { LogEntry } from \"../type/LogEntry\";\nimport { TraceId } from \"../type/TraceId\";\nimport { LogMatcher } from \"./LogMatcher\";\nimport { atLeastOneLogMatcherMatchesLogEntry } from \"./atLeastOneLogMatcherMatchesLogEntry\";\nimport { transformLogEntry } from \"./transformLogEntry\";\nimport { Stats } from \"./Stats\";\n\nexport type ObserveAgent = {\n  start: (traceId: TraceId, ...extra: unknown[]) => void;\n  log: (entry: LogEntry) => void;\n  end: (traceId: TraceId, ...extra: unknown[]) => void;\n  getStats: (traceId: TraceId) => Stats;\n  getTraceIds: () => TraceId[];\n  updateLogMatchers: (\n    fn: (logMatchers: (string | LogMatcher)[]) => (string | LogMatcher)[]\n  ) => (string | LogMatcher)[];\n};\n\nexport const ObserveAgent = ({\n  logMatchers = [],\n  logger = console.log,\n  clock = performance,\n  maxSampleSize = 100,\n}: Partial<{\n  logMatchers: (string | LogMatcher)[];\n  logger: typeof console.log;\n  clock: { now: () => number };\n  maxSampleSize: number;\n}> = {}): ObserveAgent => {\n  const stats = Caches.create<Stats>();\n\n  const mod: ObserveAgent = {\n    updateLogMatchers: (fn) => {\n      const newLogMatchers = fn(logMatchers);\n      logMatchers = newLogMatchers;\n      return newLogMatchers;\n    },\n    getTraceIds: () => stats.entries().map(([traceId]) => traceId as TraceId),\n    start: (traceId, ...extra) => {\n      mod.getStats(traceId).count();\n      mod.getStats(traceId).time();\n      mod.log({ traceId, message: \"start\", extra });\n    },\n    getStats: (traceId) => stats.get(traceId, () => Stats(maxSampleSize))!,\n\n    log: ({ traceId, message, timestamp = clock.now(), extra = [] }) => {\n      const logEntry: LogEntry = {\n        traceId,\n        message,\n        timestamp,\n        extra,\n      };\n      const logMatcherMaybe =\n        atLeastOneLogMatcherMatchesLogEntry(logMatchers)(logEntry);\n      if (!logMatcherMaybe) {\n        return;\n      }\n      const transformedLogEntry = transformLogEntry(logMatcherMaybe)(logEntry);\n      logger(\n        `${transformedLogEntry.timestamp} ${transformedLogEntry.traceId}: ${transformedLogEntry.message}`,\n        ...(transformedLogEntry.extra ?? [])\n      );\n    },\n    end: (traceId, ...extra) => {\n      mod.getStats(traceId).lastTime()?.end();\n      mod.log({ traceId, message: \"end\", extra });\n    },\n  };\n  return mod;\n};\n","import { ObserveAgent } from \"../agent/ObserveAgent\";\nimport { Timer } from \"../agent/Timer\";\n\nexport type Observe = {\n  span: (spanId: string) => Observe;\n  increment: (name: string, count?: number) => Observe;\n  gauge: (name: string, value: number) => Observe;\n  timer: (name: string) => Timer;\n  sample: (probability: number, name: string, fn: () => number) => Observe;\n  when: (filter: () => boolean, name: string, fn: () => number) => Observe;\n  log: (message: string, ...extra: unknown[]) => Observe;\n  end: () => Observe;\n};\n\nexport const Observe = (\n  traceId: string = \"\",\n  agent: ObserveAgent = ObserveAgent()\n) => {\n  agent.start(traceId);\n  const mod: Observe = {\n    span: (spanId) => Observe(`${traceId}.${spanId}`, agent),\n    increment: (name, count = 1) => {\n      agent.getStats(traceId).increment(name, count);\n      return mod;\n    },\n    sample: (probability, name, fn) => {\n      if (Math.random() < probability) {\n        const value = fn();\n        mod.gauge(name, value);\n      }\n      return mod;\n    },\n    when: (filter, name, fn) => {\n      if (filter()) {\n        const value = fn();\n        mod.gauge(name, value);\n      }\n      return mod;\n    },\n    gauge: (name, value) => {\n      agent.getStats(traceId).gauge(name, value);\n      return mod;\n    },\n    timer: (name) => {\n      return agent.getStats(traceId).timer(name);\n    },\n    end: () => {\n      agent.end(traceId);\n      return mod;\n    },\n    log: (message, ...extra) => {\n      agent.log({ traceId, message, extra });\n      return mod;\n    },\n  };\n\n  return mod;\n};\n"],"names":["parseTraceId","subject","segments","root","subpath","isProducer","valueProducer","isUndefined","obj","isDefined","valueOf","safe","producer","options","quiet","def","onError","error","Objects","getCachedObject","key","map","value","product","create","state","lastUpdated","cache","k","v","Caches","logMatcherMatchesLogEntry","logMatcher","logEntry","traceId","message","extra","timestamp","atLeastOneLogMatcherMatchesLogEntry","logMatchers","transformLogEntry","matcher","MaxLengthArray","maxLength","array","mod","Timer","start","end","Stats","max","count","counters","gauges","timers","times","last","timer","name","ts","current","ObserveAgent","logger","clock","maxSampleSize","stats","fn","newLogMatchers","logMatcherMaybe","transformedLogEntry","Observe","agent","spanId","probability","filter"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5,6,7,8,9]}